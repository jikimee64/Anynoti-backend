buildscript {
    ext {
        spring = "2.5.8"
        boot = "org.springframework.boot"
        lombok = "org.projectlombok:lombok"
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("$boot:spring-boot-gradle-plugin:$spring")
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:3.0"
    }
}

allprojects {
    group = "com.anynoti"
    version = "1.0.0"
}

subprojects {
    apply plugin: "java"
    apply plugin: 'org.sonarqube'
    apply plugin: boot
    apply plugin: "io.spring.dependency-management"
    apply plugin: "idea"
    apply plugin: 'jacoco'

    sourceCompatibility = '11'

    repositories {
        mavenCentral()
    }

    test {
        useJUnitPlatform() // JUnit5를 사용하기 위한 설정
        finalizedBy 'jacocoTestReport' // 추가
    }

    configurations {
        runtimeClasspath {
            extendsFrom developmentOnly
        }

        all{
            exclude group: 'org.apache.logging.log4j', module: 'log4j-api'
            exclude group: 'org.apache.logging.log4j', module: 'log4j-to-slf4j'
        }
    }

    dependencies {
        compileOnly lombok
        testCompileOnly lombok
        annotationProcessor lombok
        testAnnotationProcessor lombok

        implementation group: 'ch.qos.logback', name: 'logback-core', version: '1.2.9'
        implementation group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.9'

        testImplementation "$boot:spring-boot-starter-test"
    }

    jacoco {
        toolVersion = '0.8.7'
    }

    jacocoTestReport {
        reports {
            html.enabled true
            csv.enabled false
            xml.enabled true
        }

        def Qdomains = []

        for (qPattern in '**/QA'..'**/QZ') { // qPattern = '*.QA', '*.QB', ... '*.QZ'
            Qdomains.add(qPattern + '*')
        }

        afterEvaluate {
            classDirectories.setFrom(
                    files(classDirectories.files.collect {
                        fileTree(dir: it,
                                excludes: [
                                        '**/Application*',
                                ] + Qdomains
                        )
                    })
            )
        }

        finalizedBy 'jacocoTestCoverageVerification'
    }

    jacocoTestCoverageVerification {
        def Qdomains = []

        for (qPattern in '*.QA'..'*.QZ') { // qPattern = '*.QA', '*.QB', ... '*.QZ'
            Qdomains.add(qPattern + '*')
        }

        violationRules {
            rule {
                enabled = true
                element = 'CLASS'

                limit {
                    counter = 'LINE'
                    value = 'COVEREDRATIO'
                    minimum = 0.00
                }

                limit {
                    counter = 'BRANCH'
                    value = 'COVEREDRATIO'
                    minimum = 0.00
                }

                excludes = [
                        '**/Application*',
                ] + Qdomains
            }
        }

    }

    sonarqube {
        properties {
            property 'sonar.host.url', 'http://[인스턴스 ip 주소]:[포트 번호]'
            property 'sonar.login', '{SonarQube 로그인 토큰}'
            property 'sonar.sources', 'src'
            property 'sonar.language', 'java'
            property 'sonar.projectVersion', '1.1.0-SNAPSHOT'
            property 'sonar.sourceEncoding', 'UTF-8'
            property 'sonar.coverage.jacoco.xmlReportPaths', 'build/reports/jacoco/test/jacocoTestReport.xml'
            property 'sonar.java.binaries', '.'
            property 'sonar.test.inclusions', '**/*Test.java'
            property 'sonar.exclusions', '**/test/**/*, **/Q*.java, **/*Doc*.java, **/resources/**/*'
        }
    }



}


["comp"].each {
    def subProjectDir = new File(projectDir, it)
    subProjectDir.eachDir {dir->
        def projectName = ":${it}-${dir.name}"
        project(projectName){
            bootJar.enabled(false)
            jar.enabled(true)
        }
    }
}

["domain"].each {
    def subProjectDir = new File(projectDir, it)
    subProjectDir.eachDir {dir->
        def projectName = ":${it}-${dir.name}"
        project(projectName){
            bootJar.enabled(false)
            jar.enabled(true)
        }
    }
}

["server"].each {
    def subProjectDir = new File(projectDir, it)
    subProjectDir.eachDir {dir->
        def projectName = ":${it}-${dir.name}"
        project(projectName){

        }
    }
}